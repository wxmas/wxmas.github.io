---
layout: post
title: 静态链接库和动态链接库的区别
date: 2017-08-22 15:43:11 
categories:
- C
- C++
tags: 
- C
- C++
---

# 静态链接库 #

静态连接库就是把(lib)文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件；

# 动态链接库 #

动态链接库就是把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从DLL中寻找相应函数代码，因此需要相应DLL文件的支持。

# 静态链接库与动态链接库比较 #

- 静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，则无论你愿不愿意，lib 中的指令都全部被直接包含在最终生成的 EXE 文件中了。但是若使用 DLL，该 DLL 不必被包含在最终 EXE 文件中，EXE 文件执行时可以“动态”地引用和卸载这个与 EXE 独立的 DLL 文件。

- 静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。动态库就是在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。如果在当前工程中有多处对dll文件中同一个函数的调用，那么执行时，这个函数只会留下一份拷贝。但是如果有多处对lib文件中同一个函数的调用，那么执行时，该函数将在当前程序的执行空间里留下多份拷贝，而且是一处调用就产生一份拷贝。

静态链接库与静态链接库调用规则总体比较如下：

## 静态链接库(比较简单)： ##

首先，静态链接库的使用需要库的开发者提供生成库的.h头文件和.lib文件。生成库的.h头文件中的声明格式如下：

{% highlight C linenos %}
extern "C" 函数返回类型 函数名(参数表);
{% endhighlight %}

在调用程序的.cpp源代码文件中如下：

{% highlight C linenos %}
#include "../lib.h"
#pragma comment(lib,"..//debug//libTest.lib")      //指定与静态库一起链接
{% endhighlight %}

其次因为静态链接库是将全部指令都包含入调用程序生成的EXE文件中。因此如果用的是静态链接库，那么也就不存在“导出某个函数提供给用户使用”的情况，要想用就得全要！要不就都别要!

静态链接库(Lib)

在VC++6.0中new一个名称为libTest的static library工程，并新建lib.h和lib.cpp两个文件，lib.h和lib.cpp的源代码如下：

>文件：lib.h

{% highlight C linenos %}
#ifndef LIB_H
#define LIB_H
extern "C" int add(int x,int y);　　　//声明为C编译、连接方式的外部函数
#endif
{% endhighlight %}

>文件：lib.cpp

{% highlight C linenos %}
#include "lib.h"
int add(int x,int y)
{ return x + y; }
{% endhighlight %}
	
编译这个工程就得到了一个.lib文件，这个文件就是一个函数库，它提供了add的功能。将头文件和.lib文件提交给用户后，用户就可以直接使用其中的add函数了。
　　
标准Turbo C2.0中的C库函数（我们用来的scanf、printf、memcpy、strcpy等）就来自这种静态库。

下面来看看怎么使用这个库，在libTest工程所在的工作区内new一个libCall工程。libCall工程仅包含一个main.cpp文件，它演示了静态链接库的调用方法，其源代码如下：

{% highlight C++ linenos %}
#include <stdio.h>
#include "../lib.h"//不可丢失
#pragma comment( lib, "..//debug//libTest.lib" ) 　//指定与静态库一起连接

int main(int argc, char* argv[])
{
	printf( "2 + 3 = %d", add( 2, 3 ) ); 
}
{% endhighlight %}

静态链接库的调用就是这么简单，或许我们每天都在用，可是我们没有明白这个概念。代码中#pragma comment( lib , "..//debug//libTest.lib" )的意思是指本文件生成的.obj文件应与libTest.lib一起连接

## 动态链接库： ##

动态链接库的使用需要库的开发者提供生成的.lib文件和.dll文件。或者只提供dll文件。

首先我们必须先注意到DLL内的函数分为两种：

1) 外部函数，可供应用程序调用；

2) DLL内部函数，只能在 DLL 程序使用，应用程序无法调用它们。

因此调用程序若想调用DLL中的某个函数就要以某种形式或方式指明它到底想调用哪一个函数。

动态库函数的调用，可以采用静态链接的方式，主要步骤如下：

1) 包含DLL中导出的头文件。

2) 采用`#pragma comment(lib,"..//debug//libTest.lib")`导入动态库生成的*.lib头文件。或在projectàsettingsàLinkeràInput的Additional Dependencies中加入lib文件。

3) 将动态库生成的*.dll文件放到EXE或DLL的同一目录下。


也可以采用动态加载的方式调用，步骤如下：

Another.dll有一个int Add(int x,int y) 函数。则完整的调用过程如下：

{% highlight C++ linenos %}
typedef int (* FunPtr)(int,int);          //定义函数指针
FunPtr funPtr;
Handle handle =LoadLibrary("Another.dll");
funPtr =（FunPtr）GetProcAddress(handle ,"Add");
funPtr(2,3);                         // 2+3;
FreeLibrary(handle);         // 释放载入的动态库
{% endhighlight %}

# LIB文件 #

目前以lib后缀的库有两种，一种为静态链接库(Static Libary，以下简称“静态库”)，另一种为动态连接库(DLL，以下简称“动态库”)的导入库(Import Libary，以下简称“导入库”）。

静态库是一个或者多个obj文件的打包，所以有人干脆把从obj文件生成lib的过程称为Archive，即合并到一起。比如你链接一个静态库，如果其中有错，它会准确的找到是哪个obj有错，即静态lib只是壳子。

动态库一般会有对应的导入库，方便程序静态载入动态链接库，否则你可能就需要自己LoadLibary调入DLL文件，然后再手工GetProcAddress获得对应函数了。有了导入库，你只需要链接导入库后按照头文件函数接口的声明调用函数就可以了。

导入库和静态库的区别很大，他们实质是不一样的东西。静态库本身就包含了实际执行代码、符号表等等，而对于导入库而言，其实际的执行代码位于动态库中，导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息。

这也是实际上很多开源代码发布的惯用方式：

1、预编译的开发包：包含一些.dll文件和一些.lib文件。其中这里的.lib就是导入库，而不要错以为是静态库。但是引入方式和静态库一样，要在链接路径上添加找到这些.lib的路径。而.dll则最好放到最后产生的应用程序exe执行文件相同的目录。这样运行时，就会自动调入动态链接库。

2、用户自己编译：下载的是源代码，按照readme自己编译。生成很可能也是.dll + .lib(导入库)的库文件

3、如果你只有dll，并且你知道dll中函数的函数原型，那么你可以直接在自己程序中使用LoadLibary调入DLL文件，GetProcAddress获取函数地址，然后调用。

# DLL文件 #

动态链接库 (DLL) 是作为共享函数库的可执行文件。动态链接提供了一种方法，使进程可以调用不属于其可执行代码的函数。函数的可执行代码位于一个 DLL 中，该 DLL 包含一个或多个已被编译、链接并与使用它们的进程分开存储的函数。DLL 还有助于共享数据和资源。多个应用程序可同时访问内存中单个 DLL 副本的内容。

动态链接与静态链接的不同之处在于它允许可执行模块（.dll 文件或 .exe 文件）仅包含在运行时定位 DLL 函数的可执行代码所需的信息。在静态链接中，链接器从静态链接库获取所有被引用的函数，并将库同代码一起放到可执行文件中。

使用动态链接代替静态链接有若干优点。DLL 节省内存，减少交换操作，节省磁盘空间，更易于升级，提供售后支持，提供扩展 MFC 库类的机制，支持多语言程序，并使国际版本的创建轻松完成。

# 静态链接库的优点 #

(1) 代码装载速度快，执行速度略比动态链接库快； 

(2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 

# 动态链接库的优点 #

(1) 更加节省内存并减少页面交换；

(2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；

(3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；

(4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。

# 不足之处 #

(1) 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；

(2) 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。这在早期Windows中很常见。

>该文非原创，原文：[动态链接库和静态链接库的区别](http://www.cnblogs.com/gaoyihan/p/4723332.html)